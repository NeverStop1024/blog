---
title: useEffect与useLayoutEffect
date: 2023-02-15 22:22:12
permalink: /pages/a783d1/
categories:
  - 前端框架
  - React
tags:
  - 
author: 
  name: NeverStop1024
  link: https://github.com/NeverStop1024
---
![lsUrh4](https://cdn.jsdelivr.net/gh/NeverStop1024/images-store@main/uPic/lsUrh4.png)

### useEffect过程
```jsx
import { useState, useEffect } from 'react'

export default function App() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // 耗时的操做
    const pre = Date.now();
    while(Date.now() - pre < 1000) {}

    // 异步操作
    getNewList()
    // count为0时从新生成个随机数
    if (count === 0) {
      setCount(10 + Math.random() * 200);
    }
  }, [count]);

  return (
      <button onClick={() => setCount(0)}>{count}</button>
  );
}
```
1. 点击按钮，count更新，立即渲染出虚拟DOM，并与上次虚拟DOM做对比，生成最终的虚拟DOM =>   
2. 浏览器将虚拟DOM渲染到页面（将该异步任务加入任务队列） =>    
3. 检测是否有可执行的useEfffect，如果有，执行useEffect中的同步任务，然后将异步任务加入到任务队列 =>  
4. 将浏览器渲染虚拟DOM的任务从任务队列取出并执行，完成后，浏览器就可以看到变化了 =>   
5. 将useEffect中的异步任务取出执行  


**注意：**  
> **1. 在useEffect中遇到了setState**  
如果在 useEffect 中调用 setState，在同一个任务中，会先执行完当前浏览器渲染，再去做 setState 操作，因为react更新state是批量更新机制，所以setState要等下次批量更新，然后重新渲染虚拟DOM,再去做下一轮重新渲染。
### useLayoutEffect过程
```jsx
import { useState, useLayoutEffect } from 'react'

export default function App() {
  const [count, setCount] = useState(0);

  useLayoutEffect(() => {
    // 耗时的操做
    const pre = Date.now();
    while(Date.now() - pre < 1000) {}

    // 异步操作
    getNewList()
    // count为0时从新生成个随机数
    if (count === 0) {
      setCount(10 + Math.random() * 200);
    }
  }, [count]);

  return (
      <button onClick={() => setCount(0)}>{count}</button>
  );
}
```
1. 点击按钮，count更新，立即渲染出虚拟DOM，并与上次虚拟DOM做对比，生成最终的虚拟DOM =>
2. 执行useLayoutEffect中的同步任务，然后将异步任务加入到任务队列 =>
3. 浏览器将虚拟DOM渲染到页面, 完成后，浏览器就可以看到变化了=>
4. 任务队列按优先级去执行useLayoutEffect中的异步任务



### 应用场景
useEffect内需要改变 Layout 布局时，用useLLayoutEffect，其他场景用useEffect
